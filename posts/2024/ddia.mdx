---
title: 'DDIA - Kleppmann ğŸ“”'
date: '2024-05-16'
archive: false
---

Notes on DDIA - Kleppmann

543 pages

3 parts, 12 chapters

## part 1 - foundations of data systems

## c1 - RSM

database, cache, search index, stream processing, batch processing

### reliability

fault tolerant / resilient

### scalability

load parameters

response time - p95 p99 p999

tail latencies

SLO (service level objective) SLA (service level agreement)

scaling up (vertical - more powerful machine ğŸ¤–)

scaling out (horizontal)

elastic systems

### maintainability

majority of the cost of software is maintenance - ğŸÂ bugs, looking into failures, adapting it, paying tech debt, adding new features

### operability

### simplicity - big ball of mud

symptoms - explosion of state space, tight coupling of modules, tangled dependencies, inconsistent naming, hacks etc.

accidental complexity (mosely and marks, 2006) [link](https://curtclifton.net/papers/MoseleyMarks06a.pdf)

abstraction ğŸ‘

### evolvability / plasticity

### high level takeaway - RSM ğŸ˜

## c2 - data models, query languages

## SQL (based on Codd 1970)

data stored in relations (tables), where reach relation is an unordered collection of tuples (rows)

query optimizer ğŸŒˆ

## nosql (2010s) ğŸŒ²

impedance mismatch (between application code + storage layer)

CODASYL model

better for document-like structure (tree of one-to-many relationships)

declarative vs imperative languages

### mapreduce

map (aka collect) ğŸ—¾

reduce (aka fold/inject) ğŸ’‰

### graph-like data models ã€½ï¸

graph consists of vertices/nodes and edges/relationships

### triple store

SPO (subject predicate/verb object) (jim, likes, bananas)

RDF

SPARQL

Datalog

unusual data models - GenBank (genome), particle physics (LHC), information retrieval/full text search

### high level takeaway ğŸ˜

3 types - relational, document (NoSQL), graph (NoSQL)

## c3 - internals of storage systems

optimize for transactional workloads, analytics

log structured and page oriented storage engines (B-trees ğŸŒ²)

compaction â™»ï¸

SSTable (sorted string table)
red-black trees, AVL trees

memtable

Googleâ€™s BigTable paper (2006) [link](https://static.googleusercontent.com/media/research.google.com/en//archive/bigtable-osdi06.pdf)

Log-Structured Merge-Tree (LSM-Tree)

Bloom filter ğŸŒ¹

### B-tree (most widely used indexing structure) ğŸŒ²

depth of O(log n)

write-ahead log (WAL)

fuzzy search

Memcached (in-memory KV stores)

OLAP (online analytic processing)

The process of getting data into a data warehouse (is called Extract-Transform-Load (ETL))

Google Dremel (2010) [link](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf)

bitmap encoding

### high level takeaway ğŸ˜

OLTP system - user facing

OLAP system - BA facing

log structured school (append only) e.g. Cassandra, LSM tree

update-in place - B-trees

## c4 - serialization

encoding/serialization/marshalling

decoding/parsing/deserialization/unmarshalling

JSON, XML, CSV

Apache Thrift (Facebook) / Protocol Buffers (Google) (protobuf) - binary encoding libraries

protobuf does not have list/array datatype but has `repeated` marker

Apache Avro

data flows ğŸŒŠ

data outlives code

database snapshots ğŸ“¸

SOA - service oriented architecture aka microservices

2 popular approaches to web services : REST ğŸ˜Œ and SOAP ğŸ§¼

OpenAPI Specification (OAS)

RPC (remote procedure call) - tries to make a request look like calling a function/method

message broker aka message queue

actor model ğŸ‘¨â€ğŸ¤

### high level takeaway

- rolling upgrades - evolvability
- textual formats (e.g. JSON, XML, CSV) are widespread
- binary schema-driven formats like Thrift, Protocol Buffers, Avro allow compact encoding but the downside is the data needs to be decoded for humans
- data-flows include databases, RPC/REST APIs, and async message passing using message brokers/actors

## part 2 - distributed data

why distribute data - scalability, fault tolerance/ high availability, latency

shared-memory architecture ğŸ—¼

shared-disk architecture

shared-nothing architecture (horizontal scaling)

- each machine is a node

2 common ways

- replication (provides redundancy)
- paritioning/sharding

## c5 - replication

difficulty is in handling changes to data

3 popular algorithms

- single-leader
- multi-leader
- leaderless

each node that stores a copy of db is called a `replica`

leader-based replication aka active/passive aka master/slave

leader/master/primary â†’ (replication log/change stream) â†’ followers/read replicas/slaves/secondaries/hot standbys

synchronous vs asynchronous

chain replication (Azure storage)

log sequence number (Postgres), binlog coordinates (MySQL)

handling node outages

- follower failure - catch-up recovery ğŸƒ
- leader failure - failover ğŸ›‘
  - GitHub 2012-09-14, out-of-date MySQL follower promoted to leader, [link](https://github.blog/2012-09-14-github-availability-this-week/)

replication logs implementation

- write-ahead log (WAL )shipping
- logical (row-based) log replication
- trigger-based replication
  - triggers, stored procedures

eventual consistency

replication lag ğŸ®

read-after-write consistency aka read-your-writes consistency ğŸ“•

monotonic reads - wonâ€™t see time âŒšÂ go backwards

consisten prefix reads

## multi-leader replication

aka master-master / active-active replication

conflict resolution

CRDT - conflict-free replicated datatypes Riak 2.0

mergeable persistent data structures

operational transformation - Etherpad / Google Docs

replication topology - circular ğŸŸ¡, star/tree â­ğŸŒ², all-to-all

version vectors

## leaderless replication

AmazonÂ dynamo ğŸ§¨Â [link](https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf)

ACID - (atomicity, consistency, isolation, durability)

read request sent to several nodes in parallel

quorum condition:
`w + r > n` (write nodes, read nodes, n replicas ğŸ–¥ï¸)

leaderless replication â†” use case requires HA and low latency (tolerate occasional stale reads)

sloppy quorum

last write wins (LWW) - discard concurrent writes

- achieves eventual convergence at the cost of durability

### high level takeaway

- high availability (HA)
- disconnected operation
- latency
- scalability

3 main approaches

- single-leader replication (pros - no conflict resolution)
- multi-leader replication (cons - weak consistency guarantee)
- leaderless

replication can be synchronous or asynchronous

strange effects of replication lag

- read-after-write conistency
- monotonic reads
- consistent prefix reads

## c6 - partitioning

shard (MongoDB), region (HBase), tablet (Bigtable), vnode (Cassandra), vBucket (Couchbase)

unfair partitioning - skewed

partition with high load - hot spot â˜€ï¸

hash function to get partition for a key ğŸ”‘

consistent hashing aka hash partitioning (Karger et al) [link](https://www.cs.princeton.edu/courses/archive/fall09/cos518/papers/chash.pdf)

rebalancing (moving load from one node in cluster to another)

request routing / service discovery

Apache ZooKeeper (keep track of cluster metadata)

### high level takeaway

- key range partitioning
- hash partitioning

- document-partitioned indexes (local indexes)
- term-partitioned indexes (global indexes)

## c7 - transactions

ACID criteria

BASE (basically available, soft state, eventual consistency)

Atomicity - abortability

Consistency - invariants

Isolation - serializability

Durability

single vs multi-object transactions

transaction isolation

- read committed - no dirty reads, no dirty writes

databases prevent dirty writes by using row level locks

nonrepeatable read/ read skew - snapshot isolation ğŸ“¸

atomic write operation âš›ï¸

write skew

### serializability

- isolation levels are hard to understand
- solution is serializable isolation
  - literal transaction execution in order (VoltDB, Redis, Datomic)
  - two-phase locking
    - predicate locks
    - index-range locks
  - serializable snapshot isolation (SSI)\

### high level takeaway

- transaction abort
- for complex access patterns, transactions can reduce errors
- concurrency control
  - isolation levels include read committed, snapshot isolation aka repeatable read, serializable
- examples of race conditions ğŸï¸
  - dirty reads
  - dirty writes
  - read skew (nonrepeatable reads)
  - lost updates
  - write skew
  - phantom reads
- implementing serializable transactions
  - literal transaction execution in order
  - 2PL
  - SSI

## c8 - trouble with distributed systems

partial failures - nondeterministic

TCP flow control aka congestion avoidance aka backpressure

time-of-day clock (NTP) and monotonic clock â°

Byzantine faults

Byzantine fault-tolerant - even if some nodes are malicious

### high level takeaway

- first step is to detect fault

## c9 - consistency and consensus

eventual consistency / convergence

linearizability aka atomic consistency

- recency guarantee on reads/writes of a register

CAP theorem ğŸ§¢

consistency, availability, partition tolerance - pick 2 out of 3

lamport timestamp (1978)

total order broadcast

consensus

- leader election
- atomic commit

FLP result

2PC (two phase commit)

### high level takeaway

- linearizability
- causality
- consensus

## part 3 - derived data

## c10 - batch processing

unix philosophy

mapreduce

### high level takeaway

`awk, grep, sort`

2 main problems

- partitioning
- fault tolerance

join algorithms

- sort-merge joins
- broadcast hash joins
- partitioned hash joins

## c11 - stream processing

(unbounded inputs)

pub/sub model

message broker/message queue

types of windows ğŸªŸ

- tumbling window
- hopping window
- sliding window
- session window

### high level takeaway

- AMQP/JMS-style message broker
- log-based message broker

3 joins

- stream-stream joins
- stream-table joins
- table-table joins

## c12 - future of data systems

lambda architecture ğŸ‡¬ğŸ‡·

dataflow

### high level takeaway

loosely coupled components

ethical aspects of building DIA

## Conclusion

good book to read; highly recommend â˜…â˜…â˜…â˜…â˜†

## Additional sources

[A Primer on Database Replication](https://www.brianstorti.com/replication/)
